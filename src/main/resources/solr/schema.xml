<?xml version="1.0" encoding="UTF-8" ?>
<!--
This program is part of Zenoss Core, an open source monitoring platform.
Copyright (C) 2010, Zenoss Inc.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 as published by
the Free Software Foundation.

For complete information please visit: http://www.zenoss.com/oss/
-->

<!--
 For more information, on how to customize this file, please see
 http://wiki.apache.org/solr/SchemaXml
-->

<schema name="event" version="1.1">
    <types>
        <!-- The StrField type is not analyzed, but indexed/stored verbatim.
           - StrField and TextField support an optional compressThreshold which
           limits compression (if enabled in the derived fields) to values which
           exceed a certain size (in characters).
        -->
        <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>

        <!-- boolean type: "true" or "false" -->
        <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>

        <!-- numeric field types that store and index the text
             value verbatim (and hence don't support range queries, since the
             lexicographic ordering isn't equal to the numeric ordering) -->
        <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
        <fieldType name="long" class="solr.LongField" omitNorms="true"/>
        <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
        <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>


        <!-- Numeric field types that manipulate the value into
             a string value that isn't human-readable in its internal form,
             but with a lexicographic ordering the same as the numeric ordering,
             so that range queries work correctly. -->
        <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
        <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
        <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
        <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>


        <!-- The format for this date field is of the form 1995-12-31T23:59:59Z, and
           is a more restricted form of the canonical representation of dateTime
           http://www.w3.org/TR/xmlschema-2/#dateTime
           The trailing "Z" designates UTC time and is mandatory.
           Optional fractional seconds are allowed: 1995-12-31T23:59:59.999Z
           All other components are mandatory.

           Expressions can also be used to denote calculations that should be
           performed relative to "NOW" to determine the value, ie...

                 NOW/HOUR
                    ... Round to the start of the current hour
                 NOW-1DAY
                    ... Exactly 1 day prior to now
                 NOW/DAY+6MONTHS+3DAYS
                    ... 6 months and 3 days in the future from the start of
                        the current day

           Consult the DateField javadocs for more information.
        -->
        <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>

        <!-- A Trie based date field for faster date range queries and date faceting. -->
        <fieldType name="tdate" class="solr.TrieDateField" omitNorms="true" precisionStep="6" positionIncrementGap="0"/>

        <!-- A text field that only splits on whitespace for exact matching of words -->
        <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
            <analyzer>
                <tokenizer class="solr.WhitespaceTokenizerFactory"/>
            </analyzer>
        </fieldType>

        <fieldType name="event_class" class="solr.TextField">
            <analyzer>
                <tokenizer class="solr.PatternTokenizerFactory" pattern="(/([^/]+))+" group="2"/>
            </analyzer>
        </fieldType>

        <fieldType name="element_identifier" class="solr.TextField">
            <analyzer>
                <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1"
                        generateNumberParts="1" catenateWords="0"
                        catenateNumbers="0" catenateAll="0"
                        splitOnCaseChange="0"
                        splitOnNumerics="0"/>
                <tokenizer class="solr.WhitespaceTokenizerFactory"/>
            </analyzer>
        </fieldType>

        <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
        words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
        so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
        Synonyms and stopwords are customized by external files, and stemming is enabled.
        Duplicate tokens at the same position (which may result from Stemmed Synonyms or
        WordDelim parts) are removed.
        -->
        <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
            <analyzer type="index">
                <tokenizer class="solr.WhitespaceTokenizerFactory"/>
                <!-- in this example, we will only use synonyms at query time
                <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
                -->
                <!-- Case insensitive stop word removal.
                     enablePositionIncrements=true ensures that a 'gap' is left to
                     allow for accurate phrase queries.
                -->
                <!--<filter class="solr.StopFilterFactory"-->
                <!--ignoreCase="true"-->
                <!--words="stopwords.txt"-->
                <!--enablePositionIncrements="true"-->
                <!--/>-->
                <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1"
                        catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
                <filter class="solr.LowerCaseFilterFactory"/>
                <!--<filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>-->
                <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
            </analyzer>
            <analyzer type="query">
                <tokenizer class="solr.WhitespaceTokenizerFactory"/>
                <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>-->
                <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
                <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1"
                        catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
                <filter class="solr.LowerCaseFilterFactory"/>
                <!--<filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>-->
                <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
            </analyzer>
        </fieldType>


        <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
             but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
        <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100">
            <analyzer>
                <tokenizer class="solr.WhitespaceTokenizerFactory"/>
                <!--<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>-->
                <!--<filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>-->
                <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0"
                        catenateWords="1" catenateNumbers="1" catenateAll="0"/>
                <filter class="solr.LowerCaseFilterFactory"/>
                <!--<filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>-->
                <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
            </analyzer>
        </fieldType>
    </types>


    <fields>
        <field name="uuid" type="string" indexed="true" stored="true" required="true" omitNorms="true"/>
        <field name="status" type="sint" indexed="true" stored="true" omitNorms="true"/>
        <field name="count" type="sint" indexed="true" stored="true" omitNorms="true"/>
        <field name="first_seen_time" type="tdate" indexed="true" stored="true" omitNorms="true"/>
        <field name="last_seen_time" type="tdate" indexed="true" stored="true" omitNorms="true"/>
        <field name="status_change_time" type="tdate" indexed="true" stored="true" omitNorms="true"/>

        <field name="event_actor_element_type_id" type="string" stored="true" omitNorms="true"/>
        <field name="event_actor_element_uuid" type="string" stored="true" omitNorms="true"/>
        <field name="event_actor_element_identifier" type="element_identifier" indexed="true" stored="true"/>
        <field name="event_actor_element_identifier_sort" type="string" indexed="true" omitNorms="true"/>

        <field name="event_actor_element_sub_type_id" type="string" stored="true" omitNorms="true"/>
        <field name="event_actor_element_sub_uuid" type="string" stored="true" omitNorms="true"/>
        <field name="event_actor_element_sub_identifier" type="element_identifier" indexed="true" stored="true"/>
        <field name="event_actor_element_sub_identifier_sort" type="string" indexed="true" omitNorms="true"/>

        <field name="event_uuid" type="string" indexed="true" stored="true" omitNorms="true"/>
        <field name="event_summary" type="text" indexed="true" stored="true"/>
        <field name="event_summary_sort" type="string" indexed="true"/>
        <field name="event_severity" type="sint" indexed="true" stored="true" omitNorms="true"/>
        <field name="event_event_class" type="string" stored="true"/>
        <field name="event_event_class_index" type="string" indexed="true" omitNorms="true"/>

        <field name="tag" type="string" indexed="true" stored="true" multiValued="true" omitNorms="true"/>
        <!-- Since we only index the tag uuid we need to store the tag json to get the tag's other values -->
        <field name="tag_json" type="string" indexed="false" stored="true" compressed="true"/>
        
        <field name="update_time" type="tdate" indexed="true" stored="false" omitNorms="true"/>

        <field name="index_date" type="date" indexed="true" stored="true" default="NOW"/>
    </fields>

    <uniqueKey>uuid</uniqueKey>
    <defaultSearchField>event_summary</defaultSearchField>
    <solrQueryParser defaultOperator="AND"/>
    
    <copyField source="event_actor_element_identifier" dest="event_actor_element_identifier_sort"/>
    <copyField source="event_actor_element_sub_identifier" dest="event_actor_element_sub_identifier_sort"/>    
    <copyField source="event_summary" dest="event_summary_sort"/>    
</schema>